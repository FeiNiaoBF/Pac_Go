{
    "sourceFile": "pac.go",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1715927678244,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1715927727232,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,13 +16,17 @@\n \n \t\"github.com/danicat/simpleansi\"\n )\n \n-var (\n-\tconfigFile = flag.String(\"config-file\", \"config.json\", \"path to custom configuration file\")\n-\tmazeFile   = flag.String(\"maze-file\", \"maze01.txt\", \"path to a custom maze file\")\n-)\n+// // File Path\n+// var fileMaze = \"data/maze/maze02.txt\"\n \n+// // config flag\n+// var (\n+// \tconfigFile = flag.String(\"config-file\", \"config.json\", \"path to custom configuration file\")\n+// \tmazeFile   = flag.String(\"maze-file\", fileMaze, \"path to a custom maze file\")\n+// )\n+\n type sprite struct {\n \trow      int\n \tcol      int\n \tstartRow int\n"
                },
                {
                    "date": 1715927738717,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,16 +16,16 @@\n \n \t\"github.com/danicat/simpleansi\"\n )\n \n-// // File Path\n-// var fileMaze = \"data/maze/maze02.txt\"\n+// File Path\n+var fileMaze = \"data/maze/maze02.txt\"\n \n-// // config flag\n-// var (\n-// \tconfigFile = flag.String(\"config-file\", \"config.json\", \"path to custom configuration file\")\n-// \tmazeFile   = flag.String(\"maze-file\", fileMaze, \"path to a custom maze file\")\n-// )\n+// config flag\n+var (\n+\tconfigFile = flag.String(\"config-file\", \"config.json\", \"path to custom configuration file\")\n+\tmazeFile   = flag.String(\"maze-file\", fileMaze, \"path to a custom maze file\")\n+)\n \n type sprite struct {\n \trow      int\n \tcol      int\n@@ -57,9 +57,9 @@\n \tPill             string        `json:\"pill\"`\n \tDeath            string        `json:\"death\"`\n \tSpace            string        `json:\"space\"`\n \tUseEmoji         bool          `json:\"use_emoji\"`\n-\tPillDurationSecs time.Duration `json:\"pill_duration_secs\"`\n+\tPillDurationSecs time.Duration `json:\"pill_duration\"`\n }\n \n var cfg config\n var player sprite\n"
                },
                {
                    "date": 1715927744516,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,31 +44,35 @@\n \tGhostStatusNormal GhostStatus = \"Normal\"\n \tGhostStatusBlue   GhostStatus = \"Blue\"\n )\n \n-var ghostsStatusMx sync.RWMutex\n-var pillMx sync.Mutex\n+var (\n+\tghostsStatusMx sync.RWMutex\n+\tpillMx         sync.Mutex\n+)\n \n type config struct {\n-\tPlayer           string        `json:\"player\"`\n-\tGhost            string        `json:\"ghost\"`\n-\tGhostBlue        string        `json:\"ghost_blue\"`\n-\tWall             string        `json:\"wall\"`\n-\tDot              string        `json:\"dot\"`\n-\tPill             string        `json:\"pill\"`\n-\tDeath            string        `json:\"death\"`\n-\tSpace            string        `json:\"space\"`\n-\tUseEmoji         bool          `json:\"use_emoji\"`\n-\tPillDurationSecs time.Duration `json:\"pill_duration\"`\n+\tPlayer       string        `json:\"player\"`\n+\tGhost        string        `json:\"ghost\"`\n+\tGhostBlue    string        `json:\"ghost_blue\"`\n+\tWall         string        `json:\"wall\"`\n+\tDot          string        `json:\"dot\"`\n+\tPill         string        `json:\"pill\"`\n+\tDeath        string        `json:\"death\"`\n+\tSpace        string        `json:\"space\"`\n+\tUseEmoji     bool          `json:\"use_emoji\"`\n+\tPillDuration time.Duration `json:\"pill_duration\"`\n }\n \n-var cfg config\n-var player sprite\n-var ghosts []*ghost\n-var maze []string\n-var score int\n-var numDots int\n-var lives = 3\n+var (\n+\tcfg     config\n+\tplayer  sprite\n+\tghosts  []*ghost\n+\tmaze    []string\n+\tscore   int\n+\tnumDots int\n+\tlives   = 3\n+)\n \n func loadConfig(file string) error {\n \tf, err := os.Open(file)\n \tif err != nil {\n@@ -155,17 +159,17 @@\n \tghostsStatusMx.RUnlock()\n \n \tmoveCursor(len(maze)+1, 0)\n \n-\tlivesRemaining := strconv.Itoa(lives) //converts lives int to a string\n+\tlivesRemaining := strconv.Itoa(lives) // converts lives int to a string\n \tif cfg.UseEmoji {\n \t\tlivesRemaining = getLivesAsEmoji()\n \t}\n \n \tfmt.Println(\"Score:\", score, \"\\tLives:\", livesRemaining)\n }\n \n-//concatenate the correct number of player emojis based on lives\n+// concatenate the correct number of player emojis based on lives\n func getLivesAsEmoji() string {\n \tbuf := bytes.Buffer{}\n \tfor i := lives; i > 0; i-- {\n \t\tbuf.WriteString(cfg.Player)\n@@ -375,9 +379,9 @@\n \t\t\t\t\t\tfmt.Print(cfg.Death)\n \t\t\t\t\t\tmoveCursor(len(maze)+2, 0)\n \t\t\t\t\t\tghostsStatusMx.RUnlock()\n \t\t\t\t\t\tupdateGhosts(ghosts, GhostStatusNormal)\n-\t\t\t\t\t\ttime.Sleep(1000 * time.Millisecond) //dramatic pause before reseting player position\n+\t\t\t\t\t\ttime.Sleep(1000 * time.Millisecond) // dramatic pause before reseting player position\n \t\t\t\t\t\tplayer.row, player.col = player.startRow, player.startCol\n \t\t\t\t\t}\n \t\t\t\t} else if g.status == GhostStatusBlue {\n \t\t\t\t\tghostsStatusMx.RUnlock()\n"
                },
                {
                    "date": 1715927758279,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -273,9 +273,9 @@\n \tupdateGhosts(ghosts, GhostStatusBlue)\n \tif pillTimer != nil {\n \t\tpillTimer.Stop()\n \t}\n-\tpillTimer = time.NewTimer(time.Second * cfg.PillDurationSecs)\n+\tpillTimer = time.NewTimer(time.Second * cfg.PillDuration)\n \tpillMx.Unlock()\n \t<-pillTimer.C\n \tpillMx.Lock()\n \tpillTimer.Stop()\n"
                }
            ],
            "date": 1715927678244,
            "name": "Commit-0",
            "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"math/rand\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strconv\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/danicat/simpleansi\"\n)\n\nvar (\n\tconfigFile = flag.String(\"config-file\", \"config.json\", \"path to custom configuration file\")\n\tmazeFile   = flag.String(\"maze-file\", \"maze01.txt\", \"path to a custom maze file\")\n)\n\ntype sprite struct {\n\trow      int\n\tcol      int\n\tstartRow int\n\tstartCol int\n}\n\ntype ghost struct {\n\tposition sprite\n\tstatus   GhostStatus\n}\n\ntype GhostStatus string\n\nconst (\n\tGhostStatusNormal GhostStatus = \"Normal\"\n\tGhostStatusBlue   GhostStatus = \"Blue\"\n)\n\nvar ghostsStatusMx sync.RWMutex\nvar pillMx sync.Mutex\n\ntype config struct {\n\tPlayer           string        `json:\"player\"`\n\tGhost            string        `json:\"ghost\"`\n\tGhostBlue        string        `json:\"ghost_blue\"`\n\tWall             string        `json:\"wall\"`\n\tDot              string        `json:\"dot\"`\n\tPill             string        `json:\"pill\"`\n\tDeath            string        `json:\"death\"`\n\tSpace            string        `json:\"space\"`\n\tUseEmoji         bool          `json:\"use_emoji\"`\n\tPillDurationSecs time.Duration `json:\"pill_duration_secs\"`\n}\n\nvar cfg config\nvar player sprite\nvar ghosts []*ghost\nvar maze []string\nvar score int\nvar numDots int\nvar lives = 3\n\nfunc loadConfig(file string) error {\n\tf, err := os.Open(file)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\tdecoder := json.NewDecoder(f)\n\terr = decoder.Decode(&cfg)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc loadMaze(file string) error {\n\tf, err := os.Open(file)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\tscanner := bufio.NewScanner(f)\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\tmaze = append(maze, line)\n\t}\n\n\tfor row, line := range maze {\n\t\tfor col, char := range line {\n\t\t\tswitch char {\n\t\t\tcase 'P':\n\t\t\t\tplayer = sprite{row, col, row, col}\n\t\t\tcase 'G':\n\t\t\t\tghosts = append(ghosts, &ghost{sprite{row, col, row, col}, GhostStatusNormal})\n\t\t\tcase '.':\n\t\t\t\tnumDots++\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc moveCursor(row, col int) {\n\tif cfg.UseEmoji {\n\t\tsimpleansi.MoveCursor(row, col*2)\n\t} else {\n\t\tsimpleansi.MoveCursor(row, col)\n\t}\n}\n\nfunc printScreen() {\n\tsimpleansi.ClearScreen()\n\tfor _, line := range maze {\n\t\tfor _, chr := range line {\n\t\t\tswitch chr {\n\t\t\tcase '#':\n\t\t\t\tfmt.Print(simpleansi.WithBlueBackground(cfg.Wall))\n\t\t\tcase '.':\n\t\t\t\tfmt.Print(cfg.Dot)\n\t\t\tcase 'X':\n\t\t\t\tfmt.Print(cfg.Pill)\n\t\t\tdefault:\n\t\t\t\tfmt.Print(cfg.Space)\n\t\t\t}\n\t\t}\n\t\tfmt.Println()\n\t}\n\n\tmoveCursor(player.row, player.col)\n\tfmt.Print(cfg.Player)\n\n\tghostsStatusMx.RLock()\n\tfor _, g := range ghosts {\n\t\tmoveCursor(g.position.row, g.position.col)\n\t\tif g.status == GhostStatusNormal {\n\t\t\tfmt.Printf(cfg.Ghost)\n\t\t} else if g.status == GhostStatusBlue {\n\t\t\tfmt.Printf(cfg.GhostBlue)\n\t\t}\n\t}\n\tghostsStatusMx.RUnlock()\n\n\tmoveCursor(len(maze)+1, 0)\n\n\tlivesRemaining := strconv.Itoa(lives) //converts lives int to a string\n\tif cfg.UseEmoji {\n\t\tlivesRemaining = getLivesAsEmoji()\n\t}\n\n\tfmt.Println(\"Score:\", score, \"\\tLives:\", livesRemaining)\n}\n\n//concatenate the correct number of player emojis based on lives\nfunc getLivesAsEmoji() string {\n\tbuf := bytes.Buffer{}\n\tfor i := lives; i > 0; i-- {\n\t\tbuf.WriteString(cfg.Player)\n\t}\n\treturn buf.String()\n}\n\nfunc readInput() (string, error) {\n\tbuffer := make([]byte, 100)\n\n\tcnt, err := os.Stdin.Read(buffer)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif cnt == 1 && buffer[0] == 0x1b {\n\t\treturn \"ESC\", nil\n\t} else if cnt >= 3 {\n\t\tif buffer[0] == 0x1b && buffer[1] == '[' {\n\t\t\tswitch buffer[2] {\n\t\t\tcase 'A':\n\t\t\t\treturn \"UP\", nil\n\t\t\tcase 'B':\n\t\t\t\treturn \"DOWN\", nil\n\t\t\tcase 'C':\n\t\t\t\treturn \"RIGHT\", nil\n\t\t\tcase 'D':\n\t\t\t\treturn \"LEFT\", nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", nil\n}\n\nfunc makeMove(oldRow, oldCol int, dir string) (newRow, newCol int) {\n\tnewRow, newCol = oldRow, oldCol\n\n\tswitch dir {\n\tcase \"UP\":\n\t\tnewRow = newRow - 1\n\t\tif newRow < 0 {\n\t\t\tnewRow = len(maze) - 1\n\t\t}\n\tcase \"DOWN\":\n\t\tnewRow = newRow + 1\n\t\tif newRow == len(maze)-1 {\n\t\t\tnewRow = 0\n\t\t}\n\tcase \"RIGHT\":\n\t\tnewCol = newCol + 1\n\t\tif newCol == len(maze[0]) {\n\t\t\tnewCol = 0\n\t\t}\n\tcase \"LEFT\":\n\t\tnewCol = newCol - 1\n\t\tif newCol < 0 {\n\t\t\tnewCol = len(maze[0]) - 1\n\t\t}\n\t}\n\n\tif maze[newRow][newCol] == '#' {\n\t\tnewRow = oldRow\n\t\tnewCol = oldCol\n\t}\n\n\treturn\n}\n\nfunc movePlayer(dir string) {\n\tplayer.row, player.col = makeMove(player.row, player.col, dir)\n\n\tremoveDot := func(row, col int) {\n\t\tmaze[row] = maze[row][0:col] + \" \" + maze[row][col+1:]\n\t}\n\n\tswitch maze[player.row][player.col] {\n\tcase '.':\n\t\tnumDots--\n\t\tscore++\n\t\tremoveDot(player.row, player.col)\n\tcase 'X':\n\t\tscore += 10\n\t\tremoveDot(player.row, player.col)\n\t\tgo processPill()\n\t}\n}\n\nfunc updateGhosts(ghosts []*ghost, ghostStatus GhostStatus) {\n\tghostsStatusMx.Lock()\n\tdefer ghostsStatusMx.Unlock()\n\tfor _, g := range ghosts {\n\t\tg.status = ghostStatus\n\t}\n}\n\nvar pillTimer *time.Timer\n\nfunc processPill() {\n\tpillMx.Lock()\n\tupdateGhosts(ghosts, GhostStatusBlue)\n\tif pillTimer != nil {\n\t\tpillTimer.Stop()\n\t}\n\tpillTimer = time.NewTimer(time.Second * cfg.PillDurationSecs)\n\tpillMx.Unlock()\n\t<-pillTimer.C\n\tpillMx.Lock()\n\tpillTimer.Stop()\n\tupdateGhosts(ghosts, GhostStatusNormal)\n\tpillMx.Unlock()\n}\n\nfunc drawDirection() string {\n\tdir := rand.Intn(4)\n\tmove := map[int]string{\n\t\t0: \"UP\",\n\t\t1: \"DOWN\",\n\t\t2: \"RIGHT\",\n\t\t3: \"LEFT\",\n\t}\n\treturn move[dir]\n}\n\nfunc moveGhosts() {\n\tfor _, g := range ghosts {\n\t\tdir := drawDirection()\n\t\tg.position.row, g.position.col = makeMove(g.position.row, g.position.col, dir)\n\t}\n}\n\nfunc initialise() {\n\tcbTerm := exec.Command(\"stty\", \"cbreak\", \"-echo\")\n\tcbTerm.Stdin = os.Stdin\n\n\terr := cbTerm.Run()\n\tif err != nil {\n\t\tlog.Fatalln(\"unable to activate cbreak mode:\", err)\n\t}\n}\n\nfunc cleanup() {\n\tcookedTerm := exec.Command(\"stty\", \"-cbreak\", \"echo\")\n\tcookedTerm.Stdin = os.Stdin\n\n\terr := cookedTerm.Run()\n\tif err != nil {\n\t\tlog.Fatalln(\"unable to activate cooked mode:\", err)\n\t}\n}\n\nfunc main() {\n\tflag.Parse()\n\n\t// initialize game\n\tinitialise()\n\tdefer cleanup()\n\n\t// load resources\n\terr := loadMaze(*mazeFile)\n\tif err != nil {\n\t\tlog.Println(\"failed to load maze:\", err)\n\t\treturn\n\t}\n\n\terr = loadConfig(*configFile)\n\tif err != nil {\n\t\tlog.Println(\"failed to load configuration:\", err)\n\t\treturn\n\t}\n\n\t// process input (async)\n\tinput := make(chan string)\n\tgo func(ch chan<- string) {\n\t\tfor {\n\t\t\tinput, err := readInput()\n\t\t\tif err != nil {\n\t\t\t\tlog.Print(\"error reading input:\", err)\n\t\t\t\tch <- \"ESC\"\n\t\t\t}\n\t\t\tch <- input\n\t\t}\n\t}(input)\n\n\t// game loop\n\tfor {\n\t\t// process movement\n\t\tselect {\n\t\tcase inp := <-input:\n\t\t\tif inp == \"ESC\" {\n\t\t\t\tlives = 0\n\t\t\t}\n\t\t\tmovePlayer(inp)\n\t\tdefault:\n\t\t}\n\n\t\tmoveGhosts()\n\n\t\t// process collisions\n\t\tfor _, g := range ghosts {\n\t\t\tif player.row == g.position.row && player.col == g.position.col {\n\t\t\t\tghostsStatusMx.RLock()\n\t\t\t\tif g.status == GhostStatusNormal {\n\t\t\t\t\tlives = lives - 1\n\t\t\t\t\tif lives != 0 {\n\t\t\t\t\t\tmoveCursor(player.row, player.col)\n\t\t\t\t\t\tfmt.Print(cfg.Death)\n\t\t\t\t\t\tmoveCursor(len(maze)+2, 0)\n\t\t\t\t\t\tghostsStatusMx.RUnlock()\n\t\t\t\t\t\tupdateGhosts(ghosts, GhostStatusNormal)\n\t\t\t\t\t\ttime.Sleep(1000 * time.Millisecond) //dramatic pause before reseting player position\n\t\t\t\t\t\tplayer.row, player.col = player.startRow, player.startCol\n\t\t\t\t\t}\n\t\t\t\t} else if g.status == GhostStatusBlue {\n\t\t\t\t\tghostsStatusMx.RUnlock()\n\t\t\t\t\tupdateGhosts([]*ghost{g}, GhostStatusNormal)\n\t\t\t\t\tg.position.row, g.position.col = g.position.startRow, g.position.startCol\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// update screen\n\t\tprintScreen()\n\n\t\t// check game over\n\t\tif numDots == 0 || lives <= 0 {\n\t\t\tif lives == 0 {\n\t\t\t\tmoveCursor(player.row, player.col)\n\t\t\t\tfmt.Print(cfg.Death)\n\t\t\t\tmoveCursor(player.startRow, player.startCol-1)\n\t\t\t\tfmt.Print(\"GAME OVER\")\n\t\t\t\tmoveCursor(len(maze)+2, 0)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\t// repeat\n\t\ttime.Sleep(200 * time.Millisecond)\n\t}\n}\n"
        }
    ]
}